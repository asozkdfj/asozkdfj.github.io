---
    layout: posts
    title: "아이디스 1차면접후기"
    excerpt: "아이디스 1차면접후기입니다."
    categories: review
    tags: [review, blog]
    toc_label: 목차
    toc: true
    toc_sticky: true
    last_modified_at: 2023-02-15 15:57
    classes: wide
    published: false
---

- 1차면접일시 : 2023-02-01 14시  
- 1차면접장소 : 판교 아이디스타워 B1 교육장 
- 1차면접내용 : 적성검사(언어 , 수학, IT, 60분) + 손코딩(4문제)
- 1차면접후기 : 일단 판교 참으로 좋다..
오늘은 지하철을 타고 갔다. 14시 30분 시작이지만, 15분에 도착했다. 1분 자기소개를 보며  
인사당담자님께서 들어가자마자 성격의 장단점을 물어본다고 하셨다. 
장점: 침착함 + 많은 책임감
단점: 완벽함을 추구해서 일정 차질

면접이 시작되었다.
크게 보면 다음과 같다.
- 성적증명서
- SW와 HW 선택
- 프로젝트 관련
- 본 코팅테스트

자소서 기반으로 차근차근 물어보시기 시작했다. (허리디스크)
처음에 과에 대해 물어보셨다. 컴퓨터정보공학부는 SW,HW 비중이 어찌되는가? -> 반 반이라고 생각한다.
SW와 HW 모두 배우는데 왜 SW를 선택했는가? -> SW는 혼자서 공부할 수 있는데, HW는 전문적인 지식을 바탕으로
공부하기 한계가 있다.
그렇다면 자신의 SW선택했는데 다른 SW만 하는 학과랑 비교해서 경쟁력은 어디에 있는가? -> (스턴) 말잇못 -> 학과 프로젝트를 통해 어느정도 경쟁력을 갖추고 있다고 생각한다.
맨 왼쪽분이 보니까 이건 전산학과라고 보면 된다. 자기때 전산학과 어쩌구저쩌구랑 똑같다. -> (속으로 그렇구나)
그건 말이 안된다. 다른 애들은 학과 프로젝트가 없는게 아니자나. (성적을 본다.)
계절학기를 3번이나 들었는데 이 이유는 무엇인가 -> 재수강을 많이하기 위해 계절학기를 선택했다.
재수강을 왜 이렇게 많이 했는가? 2학년 1학기 때 무슨 일이 있었는가? -> 군대가기 전 공부를 열심히 하지 못했다.
학생의 본분을 다 하지 않은거 아닌가? 학생이 이모양 이꼴인데 장점을 침착함과 많은 책임감이라고 했는데
느낄수가 없지 않느냐 -> (말잇못), 맞다.
재수강 원하는 기준이 무엇이냐 -> A이상이다.
(옆에서) 결국 재수강해도 성적 못 받았네! -> (뇌정지)
이렇게 재수강해도 안되는데 얻는게 뭐냐. 왜 이따구냐.(이런 뉴양스) -> ...
<프로젝트> 여기 보면 산학연계SW는 무엇이냐 -> 졸업작품 관련 프로젝트다.
파워 분석이라 되어있는데, 설명 해봐라. -> 이것저것 설명..
파워 분석 해봤자 결국 220V 나오고 끝 아니냐 이걸로 뭘 하겠다는거냐 -> ...
분석 뜻이 결과물을 보고 해석 할 수 있다는 뜻인데, 파워 시그널을 보고 분석할 수 있는 것이냐  -> (뭔가 면접관님들이 이해를 자기 쪽으로 하신거 같아서 뇌정지)
이것은 파워 분석이 아니고 파워 관련 툴을 다루어 봤다 정도인거 같다. -> 맞다.. ( 거의 포기)
왼쪽분이 그나마 dump 관련되어서 잘 이해하실려고 노력해주셨으며, 비슷하게 알아들으셨다. 
오른쪽 분이 학과 수업을 보면 파워쪽으로는 전혀 관련이 없는데 이게 어찌된거냐? -> 관심있고 심도 있는 주제라서 선택하게 되었다.
산학협력단이라는게 있는데 거기서 플젝을 주고 선택해서 하는것으로 이해했는데 맞냐 -> 맞다.
<코테> 본인이 몇점 정도 맞은거 같냐 -> 60점은 맞았다고 생각한다.
문제 주면서, 1번에 답을 저렇게 썼는데 이유가 뭐냐 -> 그때 생각했을 때는..
말 끊고 그럼 지금 답이 뭐냐 ->  Union 보고 뇌정지 -> 8인거 같다. 
(문제 걷으면서) -> 더이상 질문이 없다 가라(꺼저라 느낌) -> 감사합니다.

그냥 종일 털리고 나왔다. 성적으로 까여서 대처가 불가능하였고, 내 SW적인 경쟁력도 다시 생각해 봐야겠다. 난 다른 공모전 프로젝트를 추가적으로 진행한 것이 없으므로
앞으로 어찌 살아야할지 모르겠다. 그리고 성적을 통해 내 장점을 연관시켜야 할거 같다. 장단점을 다시 설정하고 자소서에 반영해야 할거 같다. 
빠르면 이번주 금, 다음주 월에 나온다고 하고, 2차 면접은 다음주 목, 금이라고 하셨다.
난 무조건 불합격이고, 이는 다 내가 실력이 없기 때문이다. 
struct 구조체부터 union 까지 다 내가 실력이 없었기 때문이다.
그냥 정신이 다 털린적은 처음이다. 기분생각하면 차라리 면접을 안봤더라면 한다.
그래도 이제 내가 어디가 어찌 잘못되었는지 무엇이 부족한지, 경쟁력을 생각하고 코테 실력을 생각할 때이다.
얻은점으로 마무리하겠다.

배운 점: 
1. 자소서가 아직 너무 부족하다. (스펙도 부족하고 성적은 왜 그모양이냐)
2. 프로젝트 관련해서 설명이 너무나도 어렵다는 점이다. 진짜 답도 없다. 이걸 어찌해야할까
3. 내 경쟁력이 너무나도 부족하다.
4. 코테 볼 실력조차 안된다. 
5. 알고리즘은 물론 기본 byte 개념부터 다시 공부해야한다.

진짜 많이 무너졌다.
내일은 다시 일어날수 있을가 싶다.
진짜 너무 힘들고 잘 할 자신이 없다.
하지만 해야지 뭐 어쩌냐
오늘부터 다시 태어난다.
공부해라 병신아.

------------------------------------------------------
- 구조체 문제  
- 중복된 숫자 위치 출력 알고리즘 O(n2)과 O(n)  
- 상속 출력 문제  
- dim(n-1,k-1) + dim(n-1,k) 다이나믹 프로그래밍 문제  


------------------------------------------------------
<개념>
1. 구조체 : 
char - 1byte
short -2byte
int -  4byte
long - 4byte
float -4byte
double-8byte

구조체에서 포인터는 4byte이다.
char*이든, short*, int*, double* 상관없이 포인터는 모두 4byte이다.
union이라는 개념이란 : 구조체처럼 사용자 정의형이며, 서로 다른 자료형의 변수를 하나의 메모리 공간을 공유할 때 쓰인다.
내부 선언된 변수를 멤버변수라고 하며,
메모리 배치는 다음과 같다.
같은 메모리 공간을 공유 -> 가장 큰 자료형의 크기와 같다. ex) short랑 int가 있으면 int가 크기 때문에 int 자료형의 크기를 사용.
{}을 통해 멤버변수를 초기화한다.
union a{
    int i;
    double d;
}a;
a.i=0x1080 식으로 접근한다.
하나의 변수를 사용하는데 다른 변수에 값을 할당하지 않으면 결과를 알 수 없다. 쓰레기 값이 저장되어 있게된다.


2. 중복된 숫자의 위치 찾기 (O(n), O(n2))
O(n)

O(n2)


3. 
'''
#include <iostream>
#include <vector>
using namespace std;

class animal {
public:
    animal() {}
    void name1() { cout << "animal" << endl; }
    virtual void name2() { cout << "animal" << endl; }
};

class cat : public animal{
public:
    cat() : animal() {}
    void name1() { cout << "cat" << endl; }
    void name2() { cout << "cat" << endl; }

};
class dog : public animal{
public:
    dog() : animal() {}
    void name1() { cout << "dog" << endl; }
    void name2() { cout << "dog" << endl; }
};

int main(void) {
    animal* a= new animal();
    animal* b= new animal();
    animal* c = new cat();
    animal* d = new dog();
    a->name1();
    a->name2();
    b->name1();
    b->name2();
    c->name1();
    c->name2();
    d->name1();
    d->name2();
}

'''

4. 

Dynamic Programming
int binomial(int n, int k)
{
         for (int i=0; i<=n; i++) {
             for (int j=0; j<=k && j<=i; j++) {
                 if (k==0 || n==k)
                     binom[i][j] = 1;
                 else
                     binom[i][j] = binom[i-1][j-1] + binom[i-1][j];
                 }
         }
         return binom[n][k];
}

bottom-up 방식으로 중복 계산을 피함 